/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. grammar.jj */
/*@egen*//**
 * JJTree template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;
  UNICODE_INPUT=true;}PARSER_BEGIN(grammar)package language;

public class grammar/*@bgen(jjtree)*/implements grammarTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected static JJTgrammarState jjtree = new JJTgrammarState();

/*@egen*/  public static void main(String args [])
  {    
    if(args.length == 0) {
		java.nio.file.Path currentRelativePath = java.nio.file.Paths.get("");
		String path = currentRelativePath.toAbsolutePath().toString()+"\\src\\language\\program.txt";
      
		System.out.println("Reading from file programme.txt...");
	    //new grammar(System.in);
	    try { 
	  	  new grammar(new java.io.FileInputStream(path));
	}catch(Exception e) {
	  	System.out.println(e.getMessage());
		return;
    }
  }else {
		System.out.print("File analysis :"+args[0]);
		try {
			new grammar(new java.io.FileInputStream(args[0]));
		}catch(Exception e) {
			System.out.println(e.getMessage());
			return;
		}
    }
    try{
      SimpleNode n = grammar.Start();
      n.dump("");
      System.out.println("Thank you.");
    }
    catch(Exception e){
      System.out.println("Oops.");
      System.out.println(e.getMessage());
    }
  }
}PARSER_END(grammar)SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
/*
| < "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >*/
| < "/*" (~[ "*" ])* "*"
    (
      ~[ "/" ] (~[ "*" ])* "*"
    )*
    "/" >
}
/*
TOKEN : /* LITERALS
{
  < INTEGER_LITERAL :
    < DECIMAL_LITERAL > ([ "l", "L" ])?
  | < HEX_LITERAL > ([ "l", "L" ])?
  | < OCTAL_LITERAL > ([ "l", "L" ])? 
    >
| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >
| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >
| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >
}
*/
TOKEN : /* TERM */
{
	< COMPARATEUR :  ">"|"<"|"="|"!="|"<="|">=" >
	| < BOOLEEN : "true"|"false" >
	| < START : "STARTCODE" >
	| < END : "ENDCODE" >
	| < ENTETE : "//" >
	| < AFFEC : "<--" >
	| < ENDL : ";" >
	| < TYPE : "int" | "real" | "boolean" | "string" >
	| < RETURN : "return" >
	| < IF : "if" >
	| < ELSEIF : "else if" >
	| < ELSE : "else" >
	| < WHILE : "while" > 
	| < FOR : "for" >
	| < PARSTART : "(" >
	| < PAREND : ")" >
	| < ACCSTART : "{" >
	| < ACCEND : "}" >
	| < LOG : "AND"|"OR" >
	| < MINUS : "-" >
	| < PLUS : "+" >
	| < VIR : "," >
	| < ZERO : "0" >
	| < POINT : "." >
	| < NOT : "NOT" >
	| < COMSTART : "/*" >
	| < COMEND : "*/" >
	| < FUN : "FUN" >
	| < ENDFUN : "ENDFUN" >
	| < GUI : "\"" >
}

TOKEN : /* IDENTIFIERS */
{
  < CHIFFRE : [ "1"-"9" ] ( ["0"-"9"] )* >
| < CHIFFREBIS : [ "0"-"9" ] ( ["0"-"9"] )* >
| < IDENTIFIER :
    <  ALPHABET >
    (
	  <  ALPHABET >
    )* >
| < SYMBOLE : ["*","/","%","^"] >
| < ALPHABET : ["a"-"z", "A"-"Z"] >
| < ALPHABETNUM : [ "0"-"9" ] >
| < ALPHABETSPE : ["_","?",".","/",",",";",":","!","\u20ac","$","\u00a3","*","&","\u00e9","\"","'","(","-","\u00e8","\u00e7","\u00e0",")","=","\u00b0","+","~","#","{","[","|","`","\\","^","@","]","}"] >

}




SimpleNode Start() :
{/*@bgen(jjtree) Start */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
  try {
/*@egen*/
  < ENTETE > < IDENTIFIER > < ENTETE > BlocDec("main") {
    	java.util.ArrayList<Variable> listVariables = Variable.getVariables();
    	for(Variable var : listVariables) {
			System.out.println("Global variable "+var.getId()+" from type "+var.getType()+" created.Defined: "+var.getDefined());
    	}
    }

  	< FUN > BlocSousProgramme() {
		java.util.ArrayList<Function> listFunctions = Function.getFunctions();
		for(Function fun : listFunctions) {
			System.out.print("Function "+fun.getId()+" return type "+fun.getType()+" taking ");
			java.util.ArrayList<Parameter> listParameters = fun.getParameters();
			for(int i=0;i<listParameters.size();i++) {
				System.out.print(listParameters.get(i).getType()+" ");
			}
			System.out.println("argument(s)"+" added in the symbol table");
    	}
  	  }
  	< ENDFUN > BlocPrincipal() 
  {
    return jjtn000;
  }
  < EOF >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
  
}

void Empty():
{/*@bgen(jjtree) Empty */
  SimpleNode jjtn000 = new SimpleNode(JJTEMPTY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Empty */
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void BlocDec(String scope):
{/*@bgen(jjtree) BlocDec */
 SimpleNode jjtn000 = new SimpleNode(JJTBLOCDEC);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String type; String id; Variable var; String suite; java.util.ArrayList<Variable> listOfVariables;}
{/*@bgen(jjtree) BlocDec */
        try {
/*@egen*/
	type = type(scope) id = id(scope) suite = SuiteBlocDec(scope) < ENDL >
	{
		if(!suite.equals(type) && !suite.equals("")) {
			throw new RuntimeException("Incompatible types for "+id+" : "+suite+" differs from "+type+" in "+scope);
		}
		var = new Variable(type,id);
		var.setScope(scope);
		if(!suite.equals("")) {
			var.setDefined(true);
		}
		listOfVariables = Variable.getVariables();
		for(Variable temp : listOfVariables) {
			if(temp.getId().equals(id)) {
		  		if(temp.getScope().equals("main") || temp.getScope().equals(var.getScope())) {
					throw new RuntimeException("Variable "+id+" already defined in scope or beyond");
				}
			}
		}
		if(!scope.equals("main")) {
			Function fun = Function.getFunction(scope);
			java.util.ArrayList<Parameter> listOfParameters = fun.getParameters();
			for(Parameter par : listOfParameters) {
				if(par.getId().equals(id)) {
					throw new RuntimeException("A parameter of the function "+scope+" has the same id :"+id);
				}
			}
		}
		listOfVariables.add(var);	
	}
	 BlocDec(scope)
	| Empty()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/  
}


String SuiteBlocDec(String scope):
{/*@bgen(jjtree) SuiteBlocDec */
 SimpleNode jjtn000 = new SimpleNode(JJTSUITEBLOCDEC);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String type=""; }
{/*@bgen(jjtree) SuiteBlocDec */
         try {
/*@egen*/
	 (
	    < AFFEC > type = Valeur(scope)
		| Empty()
	)/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/{ return type; }/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}


void BlocPrincipal():
{/*@bgen(jjtree) BlocPrincipal */
  SimpleNode jjtn000 = new SimpleNode(JJTBLOCPRINCIPAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) BlocPrincipal */
        try {
/*@egen*/
	< START > BlocInstruction("main") < END >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void BlocSousProgramme():
{/*@bgen(jjtree) BlocSousProgramme */
 SimpleNode jjtn000 = new SimpleNode(JJTBLOCSOUSPROGRAMME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Function fun; }
{/*@bgen(jjtree) BlocSousProgramme */
  try {
/*@egen*/
  LOOKAHEAD(3)
  fun = Procedure("main") { System.out.println(fun.getId()+" added"); } BlocSousProgramme()
  | fun = Function("main") { System.out.println(fun.getId()+" added"); } BlocSousProgramme()
  | Empty()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


String Valeur(String scope):
{/*@bgen(jjtree) Valeur */
 SimpleNode jjtn000 = new SimpleNode(JJTVALEUR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String type;}
{/*@bgen(jjtree) Valeur */
try {
/*@egen*/
(
  LOOKAHEAD(3) type = ExpAr(scope)/*@bgen(jjtree)*/
                                   {
                                     jjtree.closeNodeScope(jjtn000, true);
                                     jjtc000 = false;
                                   }
/*@egen*/ {return type;}
| LOOKAHEAD(3) type = ExpLog(scope)/*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn000, true);
                                      jjtc000 = false;
                                    }
/*@egen*/ {return type;}
| LOOKAHEAD(3) type = ExpString(scope)/*@bgen(jjtree)*/
                                       {
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                       }
/*@egen*/ { return type;}
)/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}



  
void BlocInstruction(String scope):
{/*@bgen(jjtree) BlocInstruction */
  SimpleNode jjtn000 = new SimpleNode(JJTBLOCINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) BlocInstruction */
  try {
/*@egen*/
  Instruction(scope) BlocInstruction(scope)
|	Empty()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Instruction(String scope):
{/*@bgen(jjtree) Instruction */
  SimpleNode jjtn000 = new SimpleNode(JJTINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Instruction */
        try {
/*@egen*/
	LOOKAHEAD(2) AppelProcedure(scope)
	| Affectation(scope)
	| Boucle(scope)
	| Condition(scope)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
  

void AppelProcedure(String scope):
{/*@bgen(jjtree) AppelProcedure */
 SimpleNode jjtn000 = new SimpleNode(JJTAPPELPROCEDURE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/java.util.ArrayList<String> arg; String id; java.util.ArrayList<Function> listFunctions = new java.util.ArrayList<Function>();}
{/*@bgen(jjtree) AppelProcedure */
  try {
/*@egen*/
  (
	id = id(scope) < PARSTART > arg = Arg(scope) < PAREND > < ENDL >/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{System.out.println(id+" called in "+scope);
		listFunctions = Function.listOfFunctions;
		for(Function temp : listFunctions) {
			if(temp.getId().equals(id)) {
				if(!temp.getType().equals("void")) {
				  	throw new RuntimeException(id+" is not a procedure "+scope);
				}else {
				  	if(temp.getParameters().size() != arg.size()) {
						throw new RuntimeException("Procedure "+id+" without same parameter length in "+scope);
				  	}
					for(int j=0;j<temp.getParameters().size();j++) {
						if(!temp.getParameters().get(j).getType().equals(arg.get(j))) {
							throw new RuntimeException("Incompatible parameter types for "+id+" in "+scope);
						}
					}
				}return;
			}
		}throw new RuntimeException("Unknown procedure "+id+" in "+scope);
	}
)/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

java.util.ArrayList<String> Arg(String scope):
{/*@bgen(jjtree) Arg */
 SimpleNode jjtn000 = new SimpleNode(JJTARG);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String type; java.util.ArrayList<String> arg = new java.util.ArrayList<String>();}
{/*@bgen(jjtree) Arg */
        try {
/*@egen*/
	(
	  	type = Valeur(scope) arg = SuiteArg(scope) { arg.add(0,type); }
		| Empty()
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return arg;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

java.util.ArrayList<String> SuiteArg(String scope):
{/*@bgen(jjtree) SuiteArg */
 SimpleNode jjtn000 = new SimpleNode(JJTSUITEARG);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/java.util.ArrayList<String> arg = new java.util.ArrayList<String>(); }
{/*@bgen(jjtree) SuiteArg */
        try {
/*@egen*/
	(
	  	< VIR > arg = Arg(scope)
		| Empty()
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return arg;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Affectation(String scope):
{/*@bgen(jjtree) Affectation */
 SimpleNode jjtn000 = new SimpleNode(JJTAFFECTATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String id; String val; java.util.ArrayList<Variable> listOfVariables = new java.util.ArrayList<Variable>();}
{/*@bgen(jjtree) Affectation */
        try {
/*@egen*/
	id =id(scope) < AFFEC > val = Valeur(scope) < ENDL >/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
	  listOfVariables = Variable.getVariables();
		for(Variable var : listOfVariables) {
		  	if(var.getId().equals(id)) { 
				if(!var.getType().equals(val)) {
					throw new RuntimeException("Incompatible types for "+id+" : "+var.getType()+" differs from "+val+" in "+scope);
				}
				if(var.getScope().equals("main") || var.getScope().equals(scope)) {
				  	var.setDefined(true);
					return;
				}
			}
		}throw new RuntimeException("Variable "+id+" not declared in "+scope);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void Boucle(String scope):
{/*@bgen(jjtree) Boucle */
  SimpleNode jjtn000 = new SimpleNode(JJTBOUCLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Boucle */
        try {
/*@egen*/
	< WHILE > < PARSTART > ExpLog(scope) < PAREND > < ACCSTART > BlocInstruction(scope) < ACCEND >
|   < FOR > < PARSTART > < IDENTIFIER > < VIR > Entier(scope) < VIR > Entier(scope) < PAREND > < ACCSTART > BlocInstruction(scope) < ACCEND >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
  
}


void Condition(String scope):
{/*@bgen(jjtree) Condition */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Condition */
  try {
/*@egen*/
  < IF > < PARSTART > ExpLog(scope) < PAREND > < ACCSTART > BlocInstruction(scope) < ACCEND > SuiteCondition(scope)/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void SuiteCondition(String scope):
{/*@bgen(jjtree) SuiteCondition */
  SimpleNode jjtn000 = new SimpleNode(JJTSUITECONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) SuiteCondition */
        try {
/*@egen*/
	< ELSEIF > < PARSTART > ExpLog(scope) < PAREND > < ACCSTART > BlocInstruction(scope) < ACCEND > SuiteCondition(scope)
|  	< ELSE > < ACCSTART > BlocInstruction(scope) < ACCEND >
| 	Empty()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


String ExpAr(String scope):
{/*@bgen(jjtree) ExpAr */
 SimpleNode jjtn000 = new SimpleNode(JJTEXPAR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String type; String type2 =""; }
{/*@bgen(jjtree) ExpAr */
        try {
/*@egen*/
	type = Mult(scope) ((< PLUS >|< MINUS >) type2 = Mult(scope))*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
	  if(!type.equals(type2) && !type2.equals("")) {
			throw new RuntimeException("Types not compatible in "+scope);
		}
		return type;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


String Mult(String scope):
{/*@bgen(jjtree) Mult */
 SimpleNode jjtn000 = new SimpleNode(JJTMULT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String type; String type2 ="";}
{/*@bgen(jjtree) Mult */
        try {
/*@egen*/
	type = Unary(scope) ( < SYMBOLE > type2 = Unary(scope))*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		if(!type.equals(type2) && !type2.equals("")) {
			throw new RuntimeException("Types not compatible in "+scope);
		}
		return type;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


String Unary(String scope):
{/*@bgen(jjtree) Unary */
 SimpleNode jjtn000 = new SimpleNode(JJTUNARY);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String type; }
{/*@bgen(jjtree) Unary */
        try {
/*@egen*/
  	PreUnary() type = Element(scope)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{return type;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PreUnary():
{/*@bgen(jjtree) PreUnary */
  SimpleNode jjtn000 = new SimpleNode(JJTPREUNARY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) PreUnary */
        try {
/*@egen*/
	< MINUS > | Empty()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}



String Element(String scope):
{/*@bgen(jjtree) Element */
 SimpleNode jjtn000 = new SimpleNode(JJTELEMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String type; String id;java.util.ArrayList<Variable> listVariables;java.util.ArrayList<Parameter> listOfParameters;}
{/*@bgen(jjtree) Element */
  try {
/*@egen*/
  LOOKAHEAD(2) type = Reel(scope)/*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                  }
/*@egen*/ { return type; }
| LOOKAHEAD(2) type = AppelFunction(scope)/*@bgen(jjtree)*/
                                           {
                                             jjtree.closeNodeScope(jjtn000, true);
                                             jjtc000 = false;
                                           }
/*@egen*/ { return type; }
| < PARSTART > type = ExpAr(scope) < PAREND >/*@bgen(jjtree)*/
                                              {
                                                jjtree.closeNodeScope(jjtn000, true);
                                                jjtc000 = false;
                                              }
/*@egen*/ { return type; }
| id = id(scope)/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{   listVariables = Variable.getVariables();
			for(Variable var : listVariables) {
				if(var.getId().equals(id) && (var.getScope().equals("main") || var.getScope().equals(scope))) {
					if(!var.getType().equals("real") && !var.getType().equals("int")) {
						throw new RuntimeException("Incompatible types for "+id+" : "+var.getType()+" differs from real|int in "+scope);
					}
					if(!var.getDefined()) {
						throw new RuntimeException("Variable "+id+" is not defined");
					}
					return var.getType();
				}
			}
			if(!scope.equals("main")) {
				Function fun = Function.getFunction(scope);
				for(Parameter par : fun.getParameters()) {
					if(par.getId().equals(id)) {
						if(!par.getType().equals("real") && !par.getType().equals("int")) {
							throw new RuntimeException("Incompatible types for "+id+" : "+par.getType()+" differs from real|int in "+scope);
						}
						return par.getType();
					}
				}
			}throw new RuntimeException("Unknown variable or parameter "+id+" in scope "+scope);
		}
| type = Entier(scope)/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ { return type; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}


String AppelFunction(String scope):
{/*@bgen(jjtree) AppelFunction */
 SimpleNode jjtn000 = new SimpleNode(JJTAPPELFUNCTION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String id; java.util.ArrayList<String> arg;java.util.ArrayList<Function> listFunctions = new java.util.ArrayList<Function>();}
{/*@bgen(jjtree) AppelFunction */
        try {
/*@egen*/
	id = id(scope) < PARSTART > arg = Arg(scope) < PAREND >/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{System.out.println(id+" called in "+scope);
	  	listFunctions = Function.listOfFunctions;
		for(Function temp : listFunctions) {
			if(temp.getId().equals(id)) {
				if(temp.getType().equals("void")) {
				  	throw new RuntimeException(id+" is not a Function in "+scope);
				}else {
				  	if(temp.getParameters().size() != arg.size()) {
						throw new RuntimeException("Function "+id+" without same parameter length "+scope);
				  	}
					for(int j=0;j<temp.getParameters().size();j++) {
						if(!temp.getParameters().get(j).getType().equals(arg.get(j))) {
							throw new RuntimeException("Incompatible parameter types for "+id+" in "+scope);
						}
					}
				}return temp.getType();
			}
		}throw new RuntimeException("Unknown Function "+id+" in "+scope);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


String Entier(String scope):
{/*@bgen(jjtree) Entier */
  SimpleNode jjtn000 = new SimpleNode(JJTENTIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Entier */
  try {
/*@egen*/
  (
    < CHIFFRE >	| < ZERO >
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return "int";}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


String Reel(String scope):
{/*@bgen(jjtree) Reel */
  SimpleNode jjtn000 = new SimpleNode(JJTREEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Reel */
        try {
/*@egen*/
	Entier(scope) < POINT > SuiteReel(scope)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return "real";}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void SuiteReel(String scope):
{/*@bgen(jjtree) SuiteReel */
  SimpleNode jjtn000 = new SimpleNode(JJTSUITEREEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) SuiteReel */
        try {
/*@egen*/
	< CHIFFREBIS > | < ZERO > | < CHIFFRE >/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


String ExpLog(String scope):
{/*@bgen(jjtree) ExpLog */
 SimpleNode jjtn000 = new SimpleNode(JJTEXPLOG);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String type; String type2="" ;}
{/*@bgen(jjtree) ExpLog */
        try {
/*@egen*/
	type = UnaryL(scope) (< LOG > type2 = UnaryL(scope))*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return type;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



String UnaryL(String scope):
{/*@bgen(jjtree) UnaryL */
 SimpleNode jjtn000 = new SimpleNode(JJTUNARYL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String type;}
{/*@bgen(jjtree) UnaryL */
        try {
/*@egen*/
	type = ElementL(scope)/*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                               }
/*@egen*/ { return type;}
	| < NOT > < PARSTART > type = ElementL(scope) < PAREND >/*@bgen(jjtree)*/
                                                                 {
                                                                   jjtree.closeNodeScope(jjtn000, true);
                                                                   jjtc000 = false;
                                                                 }
/*@egen*/ { return type;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


String ElementL(String scope):
{/*@bgen(jjtree) ElementL */
 SimpleNode jjtn000 = new SimpleNode(JJTELEMENTL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String id; String typefun; String type;}
{/*@bgen(jjtree) ElementL */
        try {
/*@egen*/
	type = booleen(scope)/*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
                              }
/*@egen*/ { return type;}
	| LOOKAHEAD(3) type = Test(scope)/*@bgen(jjtree)*/
                                          {
                                            jjtree.closeNodeScope(jjtn000, true);
                                            jjtc000 = false;
                                          }
/*@egen*/ { return type; }
	| < PARSTART > type = ExpLog(scope) < PAREND >/*@bgen(jjtree)*/
                                                       {
                                                         jjtree.closeNodeScope(jjtn000, true);
                                                         jjtc000 = false;
                                                       }
/*@egen*/ { return type; }
	| LOOKAHEAD(2) typefun = AppelFunction(scope)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{System.out.println(typefun+ "called");
		  if(!typefun.equals("boolean")) {
				throw new RuntimeException("Incompatible types "+typefun+" differs from boolean in "+scope);
			}
			return typefun;
		}
	| id = id(scope)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{   java.util.ArrayList<Variable> listVariables = Variable.getVariables();
			for(Variable var : listVariables) {
				if(var.getId().equals(id) && (var.getScope().equals("main") || var.getScope().equals(scope))) {
					if(!var.getType().equals("boolean")) {
						throw new RuntimeException("Incompatible types for "+id+" : "+var.getType()+" differs from boolean in "+scope);
					}
					if(!var.getDefined()) {
						throw new RuntimeException("Variable "+id+" is not defined");
					}
					return var.getType();
				}
			}
			if(!scope.equals("main")) {
				Function fun = Function.getFunction(scope);
				java.util.ArrayList<Parameter> listOfParameters = fun.getParameters();
				for(Parameter par : listOfParameters) {
					if(par.getId().equals(id)) {
						if(!par.getType().equals("boolean")) {
							throw new RuntimeException("Incompatible types for "+id+" : "+par.getType()+" differs from boolean in "+scope);
						}
						return par.getType();
					}
				}
			}
			throw new RuntimeException("Unknown variable or parameter "+id+" in scope "+scope);
		}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

String booleen(String scope):
{/*@bgen(jjtree) booleen */
 SimpleNode jjtn000 = new SimpleNode(JJTBOOLEEN);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String type; }
{/*@bgen(jjtree) booleen */
        try {
/*@egen*/
	<  BOOLEEN >/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return "boolean";}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
  

String Test(String scope):
{/*@bgen(jjtree) Test */
  SimpleNode jjtn000 = new SimpleNode(JJTTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Test */
   try {
/*@egen*/
   ExpAr(scope) < COMPARATEUR > ExpAr(scope)/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   {return "boolean";}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}


String ExpString(String scope):
{/*@bgen(jjtree) ExpString */
 SimpleNode jjtn000 = new SimpleNode(JJTEXPSTRING);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String type; }
{/*@bgen(jjtree) ExpString */
        try {
/*@egen*/
  	type = string(scope) (< PLUS > string(scope))*/*@bgen(jjtree)*/
                                                       {
                                                         jjtree.closeNodeScope(jjtn000, true);
                                                         jjtc000 = false;
                                                       }
/*@egen*/ { return type; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	

}


String string(String scope):
{/*@bgen(jjtree) string */
 SimpleNode jjtn000 = new SimpleNode(JJTSTRING);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String type; String id; String typefun;}
{/*@bgen(jjtree) string */
        try {
/*@egen*/
	< GUI > id =id(scope) <GUI >/*@bgen(jjtree)*/
                                     {
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                     }
/*@egen*/ { return "string"; }
	
	| LOOKAHEAD(2) typefun = AppelFunction(scope)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{System.out.println(typefun+ "called");
		  if(!typefun.equals("string")) {
				throw new RuntimeException("Incompatible types "+typefun+" differs from string in "+scope);
			}
			return typefun;
		}
	| id = id(scope)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{   java.util.ArrayList<Variable> listVariables = Variable.getVariables();
			for(Variable var : listVariables) {
				if(var.getId().equals(id) && (var.getScope().equals("main") || var.getScope().equals(scope))) {
					if(!var.getType().equals("string")) {
						throw new RuntimeException("Incompatible types for "+id+" : "+var.getType()+" differs from string in "+scope);
					}
					if(!var.getDefined()) {
						throw new RuntimeException("Variable "+id+" is not defined");
					}
					return var.getType();
				}
			}
			if(!scope.equals("main")) {
				Function fun = Function.getFunction(scope);
				java.util.ArrayList<Parameter> listOfParameters = fun.getParameters();
				for(Parameter par : listOfParameters) {
					if(par.getId().equals(id)) {
						if(!par.getType().equals("string")) {
							throw new RuntimeException("Incompatible types for "+id+" : "+par.getType()+" differs from string in "+scope);
						}
						return par.getType();
					}
				}
			}
			throw new RuntimeException("Unknown variable or parameter "+id+" in scope "+scope);
		}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}



Function Function(String scope):
{/*@bgen(jjtree) Function */
 SimpleNode jjtn000 = new SimpleNode(JJTFUNCTION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String type; String id; java.util.ArrayList<Parameter> param; Function fun; String ret;}
{/*@bgen(jjtree) Function */
    try {
/*@egen*/
    
    type = type(scope) id = id(scope) < PARSTART >{System.out.println(id+" created");  fun = new Function(id, type);}
		param = Param(scope) { fun.setParameters(param); Function.getFunctions().add(fun); }< PAREND >
			< ACCSTART > Body(id) < RETURN > ret = Valeur(id) < ENDL > < ACCEND >
				{ if(!ret.equals(type)) {
					throw new RuntimeException("Return type function incompatible in "+scope);
				  }
				}/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/
			{return fun;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

String type(String scope):
{/*@bgen(jjtree) type */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) type */
  try {
/*@egen*/
  < TYPE >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return token.image;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

String id(String scope):
{/*@bgen(jjtree) id */
  SimpleNode jjtn000 = new SimpleNode(JJTID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) id */
        try {
/*@egen*/
	< IDENTIFIER >/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return token.image;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

java.util.ArrayList<Parameter> Param(String scope):
{/*@bgen(jjtree) Param */
 SimpleNode jjtn000 = new SimpleNode(JJTPARAM);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String type; java.util.ArrayList<Parameter> list = new java.util.ArrayList<Parameter>(); String id;}
{/*@bgen(jjtree) Param */
  try {
/*@egen*/
  (
    type = type(scope) id = id(scope) list = SuiteParam(scope)
    {
      Parameter arg = new Parameter(type,id);
      arg.setScope(scope);
      for(Variable var : Variable.getVariables()) {
		if(var.getScope().equals("main") && arg.getId().equals(var.getId())) {
			throw new RuntimeException("Parameter "+id+" unsetable : global variable has the same name");
		}
      }
      list.add(0,arg);
    }
    | Empty()
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return list;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

java.util.ArrayList<Parameter> SuiteParam(String scope):
{/*@bgen(jjtree) SuiteParam */
 SimpleNode jjtn000 = new SimpleNode(JJTSUITEPARAM);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/java.util.ArrayList<Parameter> list = new java.util.ArrayList<Parameter>();}
{/*@bgen(jjtree) SuiteParam */
        try {
/*@egen*/
  	(
  	   < VIR > list = Param(scope) | Empty()
  	 )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{return list;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Body(String scope):
{/*@bgen(jjtree) Body */
  SimpleNode jjtn000 = new SimpleNode(JJTBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Body */
   try {
/*@egen*/
   BlocDec(scope) BlocInstruction(scope)/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

Function Procedure(String scope):
{/*@bgen(jjtree) Procedure */
 SimpleNode jjtn000 = new SimpleNode(JJTPROCEDURE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String id; java.util.ArrayList<Parameter> param; Function fun;}
{/*@bgen(jjtree) Procedure */
        try {
/*@egen*/
  	id = id(scope) < PARSTART >{System.out.println(id +" created");  fun = new Function(id, "void");}
		param = Param(scope) { fun.setParameters(param); Function.getFunctions().add(fun);} < PAREND >
			< ACCSTART > Body(id) < ACCEND >/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/
			{return fun;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}